When you need to automatically manage the run-time lifetime of resources you can
either choose reference counting where multiple references to the same resource exist
or transfer ownership at each copy and only have a single reference to a resource at any given time.
<br/>
The two approaches result in a completely different set of implementation challenges:
<ul>
  <li>Shared ownership: serialized access to the reference counter and possibly the
resource itself (through e.g. overloading of the -&gt; operator, subject of a future
post)</li>
  <li>Single ownership: copy construction from a source object and reset of the
resource reference in the source object</li>
</ul>

This post describes a possible implementation in both <em>C++98</em> and <em>C++11</em> for a resource handler with ownership transfer similar to <tt>auto_ptr</tt>/<tt>unique_ptr</tt> to be used for resources such as file descriptors/streams, sockets and memory pointers. Note that ownership transfer is useful
when transferring pointers to heap allocated memory to avoid reallocating memory and
copying data in cases where the source buffer is destroyed anyway after the copy.

<h3>Glossary</h3>

<dl>
  <dt>resource</dt>
    <dd>any entity that follows a create-use-dispose run-time usage pattern</dd>
  <dl>handle</dl>
    <dd>the actual resource identifier: memory pointers, file and socket descriptors, OpenGL resources, OpenCL memory objects...</dd>
  <dt>handler</dt>
    <dd>the class wrapping resource handles</dd>  
</dl>
    
<h2>A minimal resource handler</h2>

A minimal resource handling class shall accept a resource identifier in its
constructor and destroy it in the destructor.<br/>
e.g.
<pre class="light: true; brush: cpp">
template &lt;typename T&gt;
class MemoryHandler {
public:
  //explicit: no automatic conversions
  explicit MemoryHandler(T* ptr) : ptr_(ptr) {}
  T* ptr() { return ptr_; }
  ~MemoryHandler() { delete ptr_; }
private:
  T* ptr_;
};
</pre>

This class can already be used to perform simple scope-based resource management: the resource is deleted when the handler goes out of scope.

<pre class="brush: cpp; light: true">
void PrintCppStd() {
  MemoryHandler&lt; Printer &gt; mh(new Printer(&quot;remote printer 1&quot;));
  Printer* p = mh.ptr();
  p-&gt;Print(&quot;./ISO_IEC_14882-2011.pdf&quot;);  
} //resource automatically destroyed by MemoryHandler destructor
</pre>

The resource is destroyed by the <tt>Printer</tt> destructor when the instance goes
out of scope, this means that there must be only a single instance of <tt>MemoryHandler</tt>
pointing to the <tt>Printer</tt> instance, if multiple instances of <tt>MemoryHandler</tt> pointing to the same <tt>Printer</tt> instance exist they will all try to delete the same
 resource resulting in a run-time error when the destructors get invoked.<br/>
<br/>
In order to enforce the single ownership requirement we need to transfer the 
<em>ownership</em>, i.e. the responsibility to manage the resource lifetime, from one 
object to another upon construction and copy operations. 

The object owning a valid resource handle is the one that shall dispose the resource
when its destructor is invoked. 

To implement ownership transfer we can start by adding a copy constructor and assignment operator accepting a non-constant reference to another reference handler which copies the pointer and resets the pointer in the source object:

<pre class="brush: cpp; light: true">
MemoryHandler(MemoryHandler&amp; mh) : ptr_(mh.ptr_) {
  mh.ptr_ = 0;
}
</pre>

A copy constructor accepting a non-constant reference can however only be used to copy
from non-temporary objects and will not work with objects returned from functions.

<h2>Ownership transfer</h2>

In order to have ownership transfer work with temporary source objects we need to implement a <em>proper</em> copy constructor and assignment operator.<br/>
<br/>
Note that assignment and construction must not only copy the resource pointer but also 
notify the source object that it has lost ownership of the resource and must not try
to dispose it.<br/>
<br/>
One way to <em>notify</em> the source object of lost ownership is to <em>simply</em> reset its inner <tt>ptr_</tt> resource handle to an empty or invalid value, i.e. to <tt>0</tt> or <tt>nullptr</tt> in the case of a memory pointer.<br/>
<br/>
The copy constructor accepting a non-const reference is useful to prevent moving 
constant resource handlers but we also need to have a constructor that allows to 
construct an object from a temporary object.</br>

<h2>Move semantics</h2>

Move semantics refers to the act of moving the content of an object into another object without performing explicit copies.<br/>
<br/>
A typical case where move semantics is <em>useful</em> is copying from a temporary object (e.g.
returned from a function) that contains a heap allocated pointer as a member variable: 
since the allocated memory is going to be released after the copy, instead of 
performing allocate-copy-free operations it is much faster to simply copy the pointer
into the new object and reset the pointer of the temporary source object to 0 so that
memory is not released when the temporary object goes out of scope.<br/>
<br/>
A typical case where move semantics is <u><em>required</em></u> is storing resource handlers requiring single ownership (e.g. sockets or C++ 11 futures) into standard library
containers. When adding an element to e.g. <tt>an std::vector</tt> the element has to
have its internal handle moved to the object stored into the container.<br/>
Note however that it might not be a good idea to store resource handlers into containers
unless you are 100% sure that no additional hidden copies happen internally during the
common container operations. It might indeed be a better idea to store the actual resource
handles in the container and have the resource handler wrap a heap allocated container
filled with handles.</br>
<br/>
Move semantics is in fact implemented in terms of ownership transfer as a copy and reset operation applied to resource handles.

<h2>Adding move semantics</h2>

The current <tt>MemoryHandler</tt> implementation can currently only be used to perform
scope-based automatic resource management.<br/>
<br/>
To fully support move semantics we need:
<ul>
  <li>a move constructor to move data from temporary objects (e.g. returned from functions) into a newly constructed object</li>
  <li>an assignment operator that can move resource handles from the r-value to the
      l-value instance</li>
</ul>

One way of supporting construction and assignment from temporary objects is to create a new type that wraps the inner resource handle and add a conversion operator and
move constructor accepting instances of this new type.<br/>
<br/>
The copy-through-proxy and reset technique is known as the Colvin and Gibbons trick. 

<img src="http://ugo.typepad.com/cpp/2013/08/cg-trick.png" width="100%"/>

The Proxy type is implemented as an inner class, no need for visibility from the outside:
<pre class="brush: cpp; light: true">
template &lt;typename T&gt; class MemoryHandler {
private:
  struct Proxy {
    T* ptr;  
  };
...
</pre> 

Conversion operator, constructor and assignment:
<pre class="brush: cpp; light: true">
operator Proxy() {
  T* ptr = ptr_;
  Proxy p;
  p.ptr = ptr;
  ptr_ = 0; //memory handler has moved out: reset this-&gt;ptr_ 
  return p;
}
MemoryHandler(const Proxy&amp; p) : ptr_(p.ptr) {}
MemoryHandler&amp; operator=(MemoryHandler&amp; mh) {
  MemoryHandler(mh).Swap(*this);
  return *this;
}
private: //helper swap method
  void Swap(MemoryHandler&amp; mh) {
    std::swap(mh.ptr_, ptr_);
  } 
</pre>

<h2>Limitations</h2>

As it stands we have a class that:
<ul>
  <li>properly manages the lifetime of a memory buffer identified by a memory handle (pointer)</li>
  <li>supports construction and assignment from non-const and temporary objects</li>
  <li>prevents constant objects from being moved</li>
</ul>

Now let's see what happens if you try to store an instance of <tt>MemoryHandler</tt>
into a standard container such as <tt>std::vector</tt>: 

<pre class="brush: cpp; light: true">
std::vector&lt; MemoryHandler&lt; int &gt; &gt; mhandlers1;
mhandlers1.push_back(MemoryHandler&lt; int &gt;(new int(1)));
std::vector&lt; MemoryHandler&lt; int &gt; &gt; mhandlers2(1);
MemoryHandler&lt; int &gt; mh(new int(1));
mhandlers2[0] = mh;
</pre>

When compiling with <tt>clang++</tt> the first reported error is:

<pre>
error: no matching constructor for initialization of 'MemoryHandler<int>'
      { ::new(__p) _Tp(__val); }
                   ^   ~~~~~
</pre>

this is because there is no copy constructor available which accepts a constant reference.<br/>
<br/>
Alternative ways to implement move semantics without the Colvin and Gibbons trick do exist e.g. add a mutable guard data member that is set to false when the object looses ownership of the resource handle and avoid destroying the resource if the object does not own it.
The problem with this approach is that it allows to move any const object preventing the implementation of e.g. the safe <tt>auto_ptr</tt> idiom.

<h2>Move semantics and standard containers</h2>

In cases where all the objects in the container must be destroyed together at the same
time: instead of storing resource handlers as elements in standard containers you can simply:
<ul>
  <li>wrap a container instance with a resource handler</li>
  <li>store the actual resource handle (e.g. a memory pointer) inside the collection</li>
</ul>

the handler's destructor will take care of iterating over the container and release every resource one by one.<br/>
<br/>
In cases where resource handlers can be inserted and removed into/from the container:
use the approach described above and </br>
<ul>
  <li>wrap elements with resource handlers when removed from the container</li>
  <li>extract resource handles from handlers when adding resources to the container</li>
</ul>

The only addition to the class required to make this strategy work is a <tt>release()</tt> method which resets the internal pointer to 0 and returns the previously stored pointer.<br/>
<br/>
The code to manage a set of handles within a container then looks like:

<pre class="brush: cpp; light: true">
MemoryHandler&lt; std::vector&lt;int*&gt; &gt; handler(new std::vector&lt; int* &gt;);
std::vector&lt;int*&gt;&amp; handles = *handler.ptr();
MemoryHandler&lt;int&gt; mhIn(CreateHandler(...));
handles.push_back(mhIn.release()); 
MemoryHandler&lt;int&gt; mhOut(handles.front());
assert(handles.front() == 0); //moved
</pre>

To perform the resource extraction and automatically reset the source handle in one call
you can use a simple reset function:

<pre class="brush: cpp; light: true">
template &lt; typename T &gt;
T* release(T*&amp; rh) {
  T* ret = rh;
  rh = 0;
  return ret;
} 
</pre>

which results in the following code:

<pre class="brush: cpp; light: true">
MemoryHandler&lt; int &gt; mhOut(reset(handles.front()));
</pre>

whether you decide to physically remove the element from the vector or not it is not a
problem since it will not cause any error upon destruction of the container.<br/>

<h2>C++ 11</h2>

If you can use a C++ 11 conformant-enough compiler such as:
<ul>
  <li>gcc >= 4.8</li>
  <li>clang llvm >= 3.2 </li>
  <li>Intel icc >= 14.0</li>
  <li>PGI >= 13.1</li>
  <li>Microsoft VS >= 2012</li> 
</ul>
you can avoid tricks and hacks and simply use r-value references to perform the move.<br/>
<br/>
Here is the same <tt>MemoryHandler</tt> class implemented with r-value references and calls to <tt>std::move</tt> when needed.

<pre class="brush: cpp; light: true">
template &lt;typename T&gt;
class MemoryHandler {
private:
    struct Proxy {
        T* ptr;  
    };
public:
    MemoryHandler(MemoryHandler&amp;&amp; mh) : ptr_(mh.ptr_) {
        mh.ptr_ = 0;
    }
    MemoryHandler(const MemoryHandler&amp;) = delete;
    explicit MemoryHandler(T* ptr = 0) : ptr_(ptr) {}
    T* ptr() { return ptr_; }
    ~MemoryHandler() { 
        delete ptr_; //it is fine to call 'delete 0'
    }
    MemoryHandler&amp; operator=(MemoryHandler&amp;&amp; mh) {
        MemoryHandler(mh).Swap(*this);
        return *this;
    }
    MemoryHandler&amp; operator=(MemoryHandler&amp; mh) {
        //cast to &amp;&amp; to properly specify the constructor to invoke
        MemoryHandler(std::move(mh)).Swap(*this);
        return *this;
    }
    MemoryHandler&amp; operator=(const MemoryHandler&amp; mh) = delete;
private:
    void Swap(MemoryHandler&amp; mh) {
        std::swap(mh.ptr_, ptr_);
    } 
private:
    T* ptr_;
};
</pre>

If you are however stuck with compilers like Open64, Cray or NVIDIA nvcc you will need to use the various strategies outlined in the previous sections for the foreseeable future.

<h2>One more thing...</h2>

Automatic resource management techniques are applied to a number of types other than memory pointer, in my case I use sockets (regular and zmq), futures, OpenCL memory objects, CUDA and OpenGL resources; it is however always possible to use versions of the <tt>MemoryHandler</tt> implemented in this article by simply wrapping the resource handles with a heap allocated instance of a wrapper class.

e.g.
<pre class="brush: cpp; light: true">
class Socket {
public:
  Socket(int s) : socket_(s) {}
  int get() { return socket_; }
  ~Socket() { close(socket_); }
private:
  int socket_;
};
...
MemoryHandler&lt; Socket &gt; 
  sh(new Socket(socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)));
int aSocket = sh.ptr()-&gt;get();
</pre>

If you want to avoid memory management operations you can always define a generic
<tt>Handler</tt> class using policy based design, you'll need policies for:
<ul>
  <li>validation: to detect if a resource can be safely disposed</li>
  <li>setting an empty/invalid value: to signal the wapper object it has lost ownership of the resource and must not try to dispose it</li>
  <li>releasing the resource: to dispose the resoure upon destruction of the resource handler instance</li>
</ul>

Note that you usually need an implementation of policy-based design or strategy
pattern to properly dipose the resource through a release function provided by client
code to the handler class; one example is the case of arrays: a <tt>delete []</tt>
operator has to be invoked instead of <tt>delete</tt>. 

A reworked version of the <tt>MemoryHandler</tt> class is shown below (C++ 11 version
only).

<pre class="brush: cpp; light: true">
template &lt;typename T,
          typename ValidationPolicy,
          typename ResetPolicy,
          typename ReleasePolicy&gt;
class Handler {
public:
    Handler(Handler&amp;&amp; h) : res_(h.res_) {
        ReleasePolicy::Reset(h.res_);
    }
    Handler(const Handler&amp;) = delete;
    explicit Handler(T res = T()) : res_(res) {
        ReleasePolicy::Reset(res_);
    }
    T&amp; get() { return res_; }
    const T&amp; get() const { return res_; }
    ~Handler() { 
        if(ValidationPolicy::Valid(res_)) {
            ReleasePolicy::Release(res_);
        }
    }
    Handler&amp; operator=(Handler&amp;&amp; h) {
        Handler(h).Swap(*this);
        return *this;
    }
    Handler&amp; operator=(Handler&amp; h) {
        //cast to &amp;&amp; to properly specify the constructor to invoke
        Handler(std::move(h)).Swap(*this);
        return *this;
    }
    Handler&amp; operator=(const Handler&amp;) = delete;
private:
    void Swap(Handler&amp; h) {
        std::swap(h.res_, res_);
    } 
private:
    T res_;
};
</pre>

Note that C++11 standard collections <strong>do</strong> support move semantics out of the box through r-value references, it is therefore possible to <em>move</em> objects into collections through the <tt>std::move</tt> function.
 
<h2>Code</h2>

Sample code is available on GitHub <a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/blog/res-handler-1.cpp">at this address</a>.






