When you need to automatically manage the run-time lifetime of resources you can
either choose reference counting where multiple references to the same resource exist
or transfer ownership at each copy (assignment) and only have a single reference to a resource at any given time.

The two approaches result in a completely different set of implementation challenges:
<ul>
  <li>Shared ownership: serialized access to the reference counter and possibly the
resource itself (through e.g. overloading of the -&gt; operator, subject of a future
post)</li>
  <li>Single ownership: copy construction from a source object and reset of the
resource reference in the source object</li>
</ul>

This post describes a possible implementation in both <em>C++98</em> and <em>C++11</em> for a resource handler with ownership transfer similar to <tt>auto_ptr</tt>/<tt>unique_ptr</tt> to be used for resources such as file descriptors/streams, sockets and threads. Note that ownership transfer is also useful
when transferring pointers to heap allocated memory to avoid reallocating memory and
copying data in cases where the source buffer is destroyed anyway after the copy.

<h2>A minimal resource handler</h2>

A resource handling class shall accept a resource handler/reference in its constructor 
and destroy it in the destructor.
e.g.
<script class="light: true; brush: cpp;" type="syntaxhighlighter"><![CDATA[
template <typename T>
class MemoryHandler {
public:
  //explicit: no automatic conversions
  explicit MemoryHandler(T* ptr) : ptr_(ptr) {}
  T* ptr() { return ptr_; }
  ~MemoryHandler() { delete ptr_; }
private:
  T* ptr_;
};
]]></script>

This class can already be used to perform simple scope-based resource management: the resource is deleted when the handler goes out of scope.

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
void PrintCppStd() {
  MemoryHandler< Printer > mh(new Printer("remote printer 1"));
  Printer* p = mh.ptr();
  p->Print("./ISO_IEC_14882-2011.pdf");  
} //resource automatically destroyed by MemoryHandler destructor
]]></script>

The resource is destroyed by the <tt>Printer</tt> destructor when the instance goes
out of scope, this means that there must be only a single instance of MemoryHandler
pointing to the Printer instance, if multiple instances of MemoryHandler pointing to
the same Printer instance exist they will all try to delete the same resource
resulting in a run-time error. In order to enforce this we can add a copy constructor accepting a non-const reference which copies the pointer and resets the pointer in the source object:

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
MemoryHandler(MemoryHandler& mh) : ptr_(mh.ptr_) {
  mh.ptr_ = 0;
}
]]></script>

to prevent assigning an object to another object we can either implement proper
operators (see further down) or simply declare the assignment operator as private.

<h2>Ownership transfer</h2>

Ownership transfer is needed when resource handlers are returned by functions and the
returned temporary object must be copied to another object.

In order to allow ownership transfer we need to implement a <em>proper</em> copy
constructor and assignment operator.
Note that assignment and construction must not only copy the resource pointer but also 
notify the source object that it has lost ownership of the resource and must not try
to dispose it.
One way to <em>notify</em> the source object of lost ownership is to <em>simply</em> reset its inner<tt>ptr_</tt> resource handler to an empty or invalid value, e.g. to 0
in the case of a memory pointer.

Implementing a copy constructor is easy: just use a non-const reference instead of a const reference this will also prevent constant object to be moved. A copy constructor
without a const reference can be used only with a pre-existing non-temporary instance
of another object; temporary objects can only be passed to constant references,
unfortunately the main reason for which we need ownership transfer is exactly to
assign temporary objects returned from functions.

One way to implement proper ownership transfer is to create a new wrapper/proxy type
that wraps the resource handler and make two additions to the class:
<ol>
  <li>an operator that returns a instance of a resource wrapper type</li>
  <li>a constructor that accepts an instance of the resource wrapper type returned by
      the operator implemented in(1)</li>
</ol>

<h2>Move semantics</h2>

Move semantics refers to the act of moving the content of an object into another
object without performing explicit copies.

A typical case where move semantics is <em>useful</em> is copying from a temporary object (e.g.
returned from a function) that contains a heap allocated pointer as a member variable: 
since the allocated memory is going to be released after the copy, instead of 
performing allocate-copy-free operations it is much faster to simply copy the pointer
into the new object and reset the pointer of the temporary source object to 0 so that
memory is not released when the temporary object goes out of scope.

A typical case where move semantics is <em>required</em> is storing resource handlers
requiring single ownership (e.g. threads and sockets) into standard library
containers. When adding an element to e.g. <tt>an std::vector</tt> the element has to
have its internal handler moved to the object stored into the container.

Move semantics is if fact implemented in terms of ownership transfer as a copy and reset operation applied to resource handlers.

<h2>Adding move semantics</h2>

The <tt>MemoryHandler</tt> implementation can currently only be used to perform
scope-based automatic resource management.

One way of supporting assignment from temporary objects is to create a new type that
wraps the inner resource handler and add a conversion operator and constructor
accepting instances of this new type.
An assignment operator is added as well.

Proxy type implemented as an inner class, no need for visibility from the outside:
<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
template <typename T> class MemoryHandler {
private:
  struct Proxy {
    T* ptr;  
  };
...
]]></script> 

Conversion operator, constructor and assignment:
<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
operator Proxy() {
  T* ptr = ptr_;
  Proxy p;
  p.ptr = ptr;
  ptr_ = 0; //memory handler has moved out: reset this->ptr_ 
  return p;
}
MemoryHandler(const Proxy& p) : ptr_(p.ptr) {}
MemoryHandler& operator=(MemoryHandler& mh) {
  MemoryHandler(mh).Swap(*this);
  return *this;
}
private: //helper swap method
  void Swap(MemoryHandler& mh) {
    std::swap(mh.ptr_, ptr_);
  } 
]]></script>

<h2>Limitations</h2>

As it stands we have a class that:
<ul>
  <li>properly manages the lifetime of a memory handle</li>
  <li>supports construction and assignment from non-const and temporary objects</li>
  <li>prevents constant objects from being moved</li>
</ul>

Now let's see what happens if you try to store an instance of <tt>MemoryHandler</tt>
into a standard container such as <tt>std::vector</tt>: 

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
std::vector< MemoryHandler< int > > mhandlers1;
mhandlers1.push_back(MemoryHandler< int >(new int(1)));
std::vector< MemoryHandler< int > > mhandlers2(1);
MemoryHandler< int > mh(new int(1));
mhandlers2[0] = mh;
]]></script>

When compiling with clang++ the reported error is:

<pre style="line-height: 0.8em">
error: no matching constructor for initialization of 'MemoryHandler<int>'
      { ::new(__p) _Tp(__val); }
                   ^   ~~~~~
</pre>

this is because there is no copy constructor available which accepts a constant reference.

Alternative ways to implement move semantics without the Colvin and Gibbons trick do exist e.g. add a mutable guard data member that is set to false when the object looses ownership of the resource handle and avoid destroying the resource if the object does not own it.
The problem with this approach is that it allows to move any const object.

<h2>Move semantics and standard containers</h2>

In cases where all objects in the container must be destroyed together instead of storing resource handlers as elements in standard containers you can simply:
<ul>
  <li>wrap a container instance with a resource handler</li>
  <li>store the actual resource handle (e.g. a memory pointer) inside the collection</li>
</ul>

in the destructor the resources handler will take care of iterating over the container and release every resource one by one.

In cases where resource handlers can be inserted and removed into/from the container:
use the approach described abve and 
<ul>
  <li>wrap elements with resource handles when removed from the container</li>
  <li>extract resource handles from handlers when adding resources to the container</li>
</ul>

The only addition to the class required to make this strategy work is a <tt>release()</tt> method which resets the internal pointer to 0 and returns the previously stored pointer.

The code to manage a set of handles within a container looks like:

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
MemoryHandler< std::vector<int*> > handler(new std::vector< int* >);
std::vector<int*>& handles = *handler.ptr();
MemoryHandler<int> mhIn(CreateHandler(...));
handles.push_back(mhIn.release()); 
MemoryHandler<int> mhOut(handles.front());
handles.front() == 0;
]]></script>

To perform the resource extraction and automatically reset the source handle in one call
you can use a simple reset function:

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
template < typename T >
T* release(T*& rh) {
  T* ret = rh;
  rh = 0;
} 
]]></script>

which results in the following code:

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
MemoryHandler<int> mhOut(reset(handles.front()));
]]></script>

whether you decide to physically remove the element from the vector or not it is not a
problem since it will not cause any error upon destruction of the container.

<h2>C++ 11</h2>

If you can use a C++ 11 conformant-enough compiler such as g++ >= 4.8, clang llvm >= 3.2, or the microsoft vs >= 2012, and probably the latest PGI as well you can avoid tricks and hacks and simply use r-value references to perform the move, here is the same <tt>MemoryHandler</tt> class implemented with r-value references and calls to <tt>std::move</tt> when needed.

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
template <typename T>
class MemoryHandler {
private:
    struct Proxy {
        T* ptr;  
    };
public:
    MemoryHandler(MemoryHandler&& mh) : ptr_(mh.ptr_) {
        mh.ptr_ = 0;
    }
    MemoryHandler(const MemoryHandler&) = delete;
    explicit MemoryHandler(T* ptr = 0) : ptr_(ptr) {}
    T* ptr() { return ptr_; }
    ~MemoryHandler() { 
        delete ptr_; //it is fine to call 'delete 0'
    }
    MemoryHandler& operator=(MemoryHandler&& mh) {
        MemoryHandler(mh).Swap(*this);
        return *this;
    }
    MemoryHandler& operator=(MemoryHandler& mh) {
        //cast to && to properly specify the constructor to invoke
        MemoryHandler(std::move(mh)).Swap(*this);
        return *this;
    }
    MemoryHandler& operator=(const MemoryHandler& mh) = delete;
private:
    void Swap(MemoryHandler& mh) {
        std::swap(mh.ptr_, ptr_);
    } 
private:
    T* ptr_;
};
]]></script>

If you are however stuck with compilers like Open64, Cray or NVIDIA nvcc you will need to use the various tricks outlined in the previous sections for the foreseeable future.

<h2>One more thing...</h2>

Automatic resource management techniques are applied to a number of types other than memory pointer, in my case I use sockets (regular and zmq), OpenCL handlers, CUDA and OpenGL resources, it is however always possible to use versions of the <tt>MemoryHandler</tt> implemented in this article by simply wrapping the resources with a class.

E.g.
<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
class Socket {
public:
  Socket(int s) : socket_(s) {}
  int get() { return socket_; }
  ~Socket() { close(socket_); }
private:
  int socket_;
};
MemoryHandler< Socket > sh(new Socket(socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)));
int aSocket = sh.ptr()->get();
]]></script>

If you want to avoid memory operation you can always define a generic <tt>Handler</tt>
class using policy based design, you'll need policies for:
<ul>
  <li>validation</li>
  <li>setting an empty/invalid value</li>
  <li>releasing the resource</li>
</ul>

A reworked version of the <tt>MemoryHandler</tt> class is shown below (C++ 11 version
only).

<script class="brush: cpp; light: true" type="syntaxhighlighter"><![CDATA[
template <typename T,
          typename ValidationPolicy,
          typename ResetPolicy,
          typename ReleasePolicy>
class Handler {
public:
    Handler(Handler&& h) : res_(h.res_) {
        ReleasePolicy::Reset(h.res_);
    }
    Handler(const Handler&) = delete;
    explicit Handler(T res = T()) : res_(res) {
        ReleasePolicy::Reset(res_);
    }
    T& get() { return res_; }
    const T& get() const { return res_; }
    ~Handler() { 
        if(ValidationPolicy::Valid(res_)) {
            ReleasePolicy::Release(res_);
        }
    }
    Handler& operator=(Handler&& h) {
        Handler(h).Swap(*this);
        return *this;
    }
    Handler& operator=(Handler& h) {
        //cast to && to properly specify the constructor to invoke
        Handler(std::move(h)).Swap(*this);
        return *this;
    }
    Handler& operator=(const Handler&) = delete;
private:
    void Swap(Handler& h) {
        std::swap(h.res_, res_);
    } 
private:
    T res_;
};
]]></script>  

Note that C++11 standard collections do support move semantics out of the box through r-value references it is therefore possible to <em>move</em> objects into collections through the <tt>std::move</tt> function.
 
<h2>Code</h2>

Sample code is available on GitHub <a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/blog/res-handler-1.cpp">at this address</a>.







