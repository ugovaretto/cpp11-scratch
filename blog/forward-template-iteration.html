Just a word on compile-time iteration with templates after having seen too much code which for no good reason forces the iteration to always go backward and specialize with 
one or zero to signal the termination condition, which is especially bad in the case
 of e.g. a tuple implementation where you end up with the types stored in the reverse order.

<h2>Backward iteration</h2>

Standard backward compile-time iteration goes like:

<pre class="brush: cpp; light: true" >
template &lt; int Counter,.... &gt; //iteration step
struct Iterator {
  static void Do() {
    ...   
    Iterator&lt; Counter - 1, ... &gt;::Do()
  }
};

template &lt; ... &gt; //end iteration
struct Iterator&lt; 1, ... &gt; {
  static void Do() {
    ...   
  }
};
</pre>

or with derivation:

<pre class="brush: cpp; light: true">
template &lt; int Counter, .... &gt; 
struct Iterable : Iterable&lt; Counter - 1, ... &gt; {...};

template &lt; ... &gt; //end iteration
struct Iterable&lt; 0, ... &gt; {...};
</pre>

Apart from iterating backward you are also losing information about the actual 
iteration length in each step, easily fixed by adding an additional constant (i.e. all template specializations have the same value) template parameter holding the number of
iteration steps.<br/>
</br>
As an example of a compile-time backward iteration let's implement a function that
prints a message a constant number of times:

<pre class="brush: cpp; light: true">
#include &lt;iostream&gt;

template &lt; int N &gt; 
struct ReversePrinter {
    static void Print() {
        for(int t = 0; t != N - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; N &lt;&lt; '\n';
        ReversePrinter&lt; N - 1 &gt;::Print();
    }    
};

template &lt;&gt;
struct ReversePrinter&lt; 1 &gt; {
    static void Print() {
        std::cout &lt;&lt; &quot;Iteration 0&quot; &lt;&lt; std::endl;
    }
};

int main(int, char**) {
    std::cout &lt;&lt; &quot;Standard reverse iterator:\n&quot;;
    ReversePrinter&lt; 3 &gt;::Print();
    return 0;
}
</pre>

If you compile and run the above code you get:

<pre>
Standard reverse iterator:
    Iteration 3
  Iteration 2
Iteration 1
</pre>

Note that it is not possible to properly indent the output because there is no
information about the number of steps so an additional template parameter has to
be added e.g.

<pre class="brush: cpp; light: true">
template &lt; int N, ...., int NumIterations = N &gt;
...
</pre>

In order to keep the public interface intact it is also possible to create a helper class accepting both the counter and number of iterations and use it to perform the
actual iteration.

<h2>Forward iteration</h2>

Forward iteration can easily be implemented following the following pattern:

<pre class="brush: cpp; light: true">
template &lt; int NumIterations, int Counter, ... &gt;
struct Iterator {
  static void Do() {
    ...   
    Iterator&lt; NumIterations, Counter + 1, ... &gt;::Do()
  }
};

template &lt; ... &gt; //end iteration
struct Iterator&lt; NumIterations, NumIterations, ... &gt; {
  static void Do() {
    ...   
  }
};
</pre>

The trick is to use the amazing pattern matching capabilities of templates and 
specialize with <tt>Counter == NumIterations</tt> i.e. stopping the iteration when
both <tt>Counter</tt> and <tt>NumIterations</tt> have the same value.<br/> 
<br/>
Whith this approach the compile-time print algorithm is easily implemented as:

<pre class="brush: cpp; light: true">
#include &lt;iostream&gt;

template &lt; int N, int Count = 1 &gt; 
struct Printer {                  
    static void Print() {         
        for(int t = 0; t != Count - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; Count &lt;&lt; '\n'; 
        Printer&lt; N, Count + 1 &gt;::Print();
    }
};

template &lt; int N &gt;
struct Printer&lt; N, N &gt; {
    static void Print() {
        for(int t = 0; t != N - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; N &lt;&lt; std::endl;
    }
};

int main(int, char**) {
    std::cout &lt;&lt; &quot;Standard reverse iterator:\n&quot;;
    ReversePrinter&lt; 3 &gt;::Print();
    std::cout &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;Forward iterator:\n&quot;;
    Printer&lt; 3 &gt;::Print();
    return 0;
}
</pre>

which leads to the following output:

<pre>
Forward iterator:
Iteration 1
  Iteration 2
    Iteration 3
</pre>

As you can see the iteration takes place in the forward order.<br/>
<br/>
The <tt>Counter</tt> itself can be default initialized to one or we can use a helper
class to leave the public interface untouched.

<h2>Resources</h1>

<a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/blog/forward-template-iteration.cpp">Code</a><br/>

<a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/tuple11.cpp">A recursive tuple implementation (C++11)</a>
Just a word on compile-time iteration with templates after having seen too much code which for no good reason forces the iteration to always go backward and specialize with 
one or zero to signal the termination condition, which is especially bad in the case
 of e.g. a tuple implementation where you end up with the types stored in the reverse order.

<h2>Backward iteration</h2>

Standard backward compile-time iteration goes like:

<pre class="brush: cpp; light: true" >
template &lt; int Counter,.... &gt; //iteration step
struct Iterator {
  static void Do() {
    ...   
    Iterator&lt; Counter - 1, ... &gt;::Do()
  }
};

template &lt; ... &gt; //end iteration
struct Iterator&lt; 1, ... &gt; {
  static void Do() {
    ...   
  }
};
</pre>

or with derivation:

<pre class="brush: cpp; light: true">
template &lt; int Counter, .... &gt; 
struct Iterable : Iterable&lt; Counter - 1, ... &gt; {...};

template &lt; ... &gt; //end iteration
struct Iterable&lt; 0, ... &gt; {...};
</pre>

Apart from iterating backward you are also losing information about the actual 
iteration length in each step, easily fixed by adding an additional constant (i.e. all template specializations have the same value) template parameter holding the number of
iteration steps.<br/>
</br>
As an example of a compile-time backward iteration let's implement a function that
prints a message a constant number of times:

<pre class="brush: cpp; light: true">
#include &lt;iostream&gt;

template &lt; int N &gt; 
struct ReversePrinter {
    static void Print() {
        for(int t = 0; t != N - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; N &lt;&lt; '\n';
        ReversePrinter&lt; N - 1 &gt;::Print();
    }    
};

template &lt;&gt;
struct ReversePrinter&lt; 1 &gt; {
    static void Print() {
        std::cout &lt;&lt; &quot;Iteration 0&quot; &lt;&lt; std::endl;
    }
};

int main(int, char**) {
    std::cout &lt;&lt; &quot;Standard reverse iterator:\n&quot;;
    ReversePrinter&lt; 3 &gt;::Print();
    return 0;
}
</pre>

If you compile and run the above code you get:

<pre>
Standard reverse iterator:
    Iteration 3
  Iteration 2
Iteration 1
</pre>

Note that it is not possible to properly indent the output because there is no
information about the number of steps so an additional template parameter has to
be added e.g.

<pre class="brush: cpp; light: true">
template &lt; int N, ...., int NumIterations = N &gt;
...
</pre>

In order to keep the public interface intact it is also possible to create a helper class accepting both the counter and number of iterations and use it to perform the
actual iteration.

<h2>Forward iteration</h2>

Forward iteration can easily be implemented following the following pattern:

<pre class="brush: cpp; light: true">
template &lt; int NumIterations, int Counter, ... &gt;
struct Iterator {
  static void Do() {
    ...   
    Iterator&lt; NumIterations, Counter + 1, ... &gt;::Do()
  }
};

template &lt; ... &gt; //end iteration
struct Iterator&lt; NumIterations, NumIterations, ... &gt; {
  static void Do() {
    ...   
  }
};
</pre>

The trick is to use the amazing pattern matching capabilities of templates and 
specialize with <tt>Counter == NumIterations</tt> i.e. stopping the iteration when
both <tt>Counter</tt> and <tt>NumIterations</tt> have the same value.<br/> 
<br/>
Whith this approach the compile-time print algorithm is easily implemented as:

<pre class="brush: cpp; light: true">
#include &lt;iostream&gt;

template &lt; int N, int Count = 1 &gt; 
struct Printer {                  
    static void Print() {         
        for(int t = 0; t != Count - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; Count &lt;&lt; '\n'; 
        Printer&lt; N, Count + 1 &gt;::Print();
    }
};

template &lt; int N &gt;
struct Printer&lt; N, N &gt; {
    static void Print() {
        for(int t = 0; t != N - 1; ++t) std::cout &lt;&lt; &quot;  &quot;;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; N &lt;&lt; std::endl;
    }
};

int main(int, char**) {
    std::cout &lt;&lt; &quot;Standard reverse iterator:\n&quot;;
    ReversePrinter&lt; 3 &gt;::Print();
    std::cout &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;Forward iterator:\n&quot;;
    Printer&lt; 3 &gt;::Print();
    return 0;
}
</pre>

which leads to the following output:

<pre>
Forward iterator:
Iteration 1
  Iteration 2
    Iteration 3
</pre>

As you can see the iteration takes place in the forward order.<br/>
<br/>
The <tt>Counter</tt> itself can be default initialized to one or we can use a helper
class to leave the public interface untouched.

<h2>Resources</h1>

<a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/blog/forward-template-iteration.cpp">Code</a><br/>

<a href="https://github.com/ugovaretto/cpp11-scratch/blob/master/tuple11.cpp">A recursive tuple implementation (C++11)</a>
