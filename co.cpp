#include <iostream>#include <fstream>#include <string>//#include <regex>#include <functional>// template < typename T > struct Iter : T { //     Iter() : iterend_(new Iter) {}//     const Iter& begin() const { //         if(T::operator bool()) return *this;//         else return *iterend_;//     }//     const Iter& end() const { return *iterend_; }//     const typename T::value_type operator*() const { return T::operator(); }//     const Iter& operator++() const { //         return T::operator bool() ? *this: *iterend_;//     }//     ~Iter() { delete iterend_; }    // private://     Iter* iterend_;    // };// class Reader {// public:    //     const std::string& operator()(const char* c = 0) {//         if( c && !is_.is_open() ) is_.open(c);//         std::getline(is_, line_);//         return line_;    //     }//     operator bool() const  { return is_; }// private://     mutable std::string line_;//     std::ifstream is_;// };// class Filter {// public:    //     const std::string& operator()(const std::regex& rx,//                                   const std::string& s) {//         if(std::regex_match(s,rx)) return s;//         else return std::string();               //     }//     template < typename T > bool operator ()(const T& t) const {//        return t;//     }  // };// class Printer {// public://    template < typename T > bool operator ()(const T& t) const {//        return t;//    }  //    void operator()(const std::string& s) const {//        if(s.empty()) return;//        std::cout << s << std::endl; //    }// };// std::function< std::string (const char*) > co() {//     std::ifstream is;//     std::string line;//     return [=](const char* name = 0) mutable {//         //if( name && !is.is_open() ) is.open(name);//         std::getline(is, line);//         return line;     //     };// }#ifndef WIN32#define TLS __thread#else#define TLS __declspec(thread)#endif// template <typename T>// bool read(std::istream& is, T out) {//     static TLS std::string* buf = new std::string;//     if(!is) {//         delete buf;//         return false;//     }//     std::getline(is, *buf);//     const bool ret = out(*buf) && is;//     if(!ret) delete buf;//     return ret;// }// template <typename T>// bool filter(const std::string& s, T out) {//     if(s.size() > 0) return out(s);//     return true;// }// bool print(const std::string& s) {//     std::cout << s << std::endl;//     return true;// }// struct S {//     int operator()() { return 1;}// };// template < typename T, typename C > std::function< T > make_fun(C t) {//     return std::function< T >(t);// }// template < typename T > // std::function<//   typename std::enable_if< //      std::is_function< T >::value, T >::type >// make_fun(T* t) {//     return std::function< T >(t);// }// int main(int, char**) {  //     typedef std::function< bool (const std::string&) > TT;//     using namespace std::placeholders;//     std::ifstream is("afile");//     // auto a = mf(print);//     // auto b = mf< int (void) >(S());//     // auto F = std::bind(foo, _1, 6);//     // F(5);//     while(read(is, std::bind(filter<TT>, _1, print)));//     //the following works if operator bool() triggers computation//     //while(Read(is, Filter("\d", Print(std::cout))))  //     // Printer print;//     // Reader read;//     // Filter filter;//     // std::cout << std::regex_match("1",std::regex("[[:digit:]]")) << std::endl;//     // return 1;//     // do //     //     print(filter(std::regex("\\d"),read("afile")));//     // while(print(read));//     return 0;// }struct Counter {public:    struct Iter {        Counter* c_;        bool operator !=(const Iter& c) {            return c_->counter_ != c.c_->bound_;        }        Iter operator++() {            c_->counter_++;            return *this;        }        int operator*() const { return c_->counter_; }    };        Counter(int limit) : counter_(0), bound_(limit + 1) {}    Iter begin() { return Iter{this}; }    Iter end() { return Iter{this}; }    int counter_;    int bound_;};int mul(int v) { return 2 * v; }int print(int v) { std::cout << v << ' '; return v;}template <typename T>struct context {    T d;};int count(context<int>& c) {    return c.d--;}struct Generator {    struct Iter {        Counter* c_;    bool operator !=(const Iter& c) {        return c_->counter_ != c.c_->bound_;    }    Iter operator++() {        c_->counter_++;        return *this;    }        int operator*() const { return c_->counter_; }    };        Generator(std::function<int (int)> f) : f_(f) {    }    Iter begin() { return Iter{this}; }    Iter end() { return Iter{this}; }    int counter_;    int bound_;};int main(int argc, char** argv) {    Counter C1 = {10};    Counter C2(C1);    Generator(std::function< int (int) > f =              [](int i) { return 2*i;}) :     for(auto i : C1) std::cout << i << std::endl;     std::for_each(C2.begin(), C2.end(), [](int i) { std::cout << i << '\n';});    context<int> c = {10};    while(print(mul(count(c))));    return 0;}